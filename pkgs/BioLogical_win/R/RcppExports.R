# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' C++ prototype function for BoolFun_Type()
#' @param boolfunss, bool function logical vector.
#' @param k, input variable size.
#' @param Leixing, function's type.
#' @param Showit, whether show the function?
#' @details Please see document of \link{BoolFun_Type}
c_BF_isPointed <- function(boolfunss, k, Leixing, Showit) {
    .Call(`_BioLogical_c_BF_isPointed`, boolfunss, k, Leixing, Showit)
}

#' C++ prototype function for BoolFun_Generator()
#' @param Leixing, function's type.
#' @param k, input variable size.
#' @param bias, function's bias.
#' @param Vars, some configuration parameters.
#' @details Please see document of \link{BoolFun_Generator}
c_BF_Generator <- function(Leixing, k, bias, Vars) {
    .Call(`_BioLogical_c_BF_Generator`, Leixing, k, bias, Vars)
}

#' C++ prototype function for BoolFun_Sensitivity()
#' @param boolfunss, bool function logical vector.
#' @param k, input variable size.
#' @details Please see document of \link{BoolFun_Sensitivity}
c_BF_Sensitivity <- function(boolfunss, k) {
    .Call(`_BioLogical_c_BF_Sensitivity`, boolfunss, k)
}

#' C++ prototype function for BoolFun_EffectiveEdges()
#' @param boolfunss, bool function logical vector.
#' @param k, input variable size.
#' @details Please see document of \link{BoolFun_EffectiveEdges}
c_BF_Effective <- function(boolfunss, k) {
    .Call(`_BioLogical_c_BF_Effective`, boolfunss, k)
}

#' C++ prototype function for BoolFun_Complexity()
#' @param boolfunss, bool function logical vector.
#' @param k, input variable size.
#' @details Please see document of \link{BoolFun_Complexity}
c_BF_Complexity <- function(boolfunss, k) {
    .Call(`_BioLogical_c_BF_Complexity`, boolfunss, k)
}

#' C++ prototype function for BoolFun_EffectiveEdges()
#' @param boolfunss, truth table.
#' @param k, input variable size.
#' @details Please see document of \link{BoolFun_EffectiveEdges}
c_BF_EffectiveEdges <- function(boolfunss, k) {
    .Call(`_BioLogical_c_BF_EffectiveEdges`, boolfunss, k)
}

#' C++ prototype function for BoolFun_QMForm()
#' @param boolfunss, bool function logical vector.
#' @param k, input variable size.
#' @param VarsName, variables' names.
#' @details Please see document of \link{BoolFun_QMForm}
c_BF_QuineMcCluskey <- function(boolfunss, k, VarsName) {
    invisible(.Call(`_BioLogical_c_BF_QuineMcCluskey`, boolfunss, k, VarsName))
}

#' C++ prototype function for FrameTruthTable()
#' @param VarNum, input variable size.
c_FrameTruthTable <- function(VarNum) {
    .Call(`_BioLogical_c_FrameTruthTable`, VarNum)
}

#' C++ prototype function for BoolFun_NestedCanalized()
#' @param boolfunss, truth table.
#' @param k, input variable size.
#' @details Please see document of \link{BoolFun_NestedCanalized}
c_B_NestedCanalized <- function(boolfunss, k) {
    .Call(`_BioLogical_c_B_NestedCanalized`, boolfunss, k)
}

#' C++ prototype function for DNS_DamageSpread()
#' @param sys_size, system size
#' @param ll_system, level number of discrete system
#' @param sim_step, simulating steps
#' @param obf_type, ordered Boolean function type
#' @param bias_rf, biases in random function 
#' @param obf_ratio, proportion of ordered Boolean function 
#' @param init_dis, initial normalized Hamming distance
#' @param init_1_ratio, "1" proportion of initial vector
#' @param net_type, system topological type
#' @param net_f_para, topological configured parameters
#' @param obf_i_para1, configuration parameter for OBF (1)
#' @param obf_i_para2, configuration parameter for OBF (2)
#' @param RuleType, update strategy 
#' @details Please see document of \link{DNS_DamageSpread}
c_Derrida_Simualtion <- function(sys_size, ll_system, sim_step, obf_type, bias_rf, obf_ratio, init_dis, init_1_ratio, net_type, net_f_para, obf_i_para1, obf_i_para2, RuleType) {
    .Call(`_BioLogical_c_Derrida_Simualtion`, sys_size, ll_system, sim_step, obf_type, bias_rf, obf_ratio, init_dis, init_1_ratio, net_type, net_f_para, obf_i_para1, obf_i_para2, RuleType)
}

#' C++ prototype function for DNS_Percolation()
#' @param sys_size, system size
#' @param ll_system, level number of discrete system
#' @param sim_step, simulating steps
#' @param lat_type, lattice type
#' @param obr_window, Observe window
#' @param obf_type, ordered Boolean function type
#' @param bias_rf, biases in random function 
#' @param obf_ratio, proportion of ordered Boolean function 
#' @param init_bias, each 
#' @param net_type, system topological type
#' @param net_f_para, topological configured parameters
#' @param obf_i_para1, configuration parameter for OBF (1)
#' @param obf_i_para2, configuration parameter for OBF (2)
#' @param OutPut, whehther output all states?
#' @param RuleType, update strategy
#' @details Please see document of \link{DNS_Percolation}
c_Percolation_Simualtion <- function(sys_size, ll_system, sim_step, lat_type, obr_window, obf_type, bias_rf, obf_ratio, init_bias, net_type, net_f_para, obf_i_para1, obf_i_para2, OutPut, RuleType) {
    .Call(`_BioLogical_c_Percolation_Simualtion`, sys_size, ll_system, sim_step, lat_type, obr_window, obf_type, bias_rf, obf_ratio, init_bias, net_type, net_f_para, obf_i_para1, obf_i_para2, OutPut, RuleType)
}

#' C++ prototype function for DNS_Engaged()
#' @param sys_size, system size
#' @param ll_system, level number of discrete system
#' @param obf_type, ordered Boolean function type
#' @param bias_rf, biases in random function 
#' @param obf_ratio, proportion of ordered Boolean function 
#' @param net_type, system topological type
#' @param net_f_para, topological configured parameters
#' @param obf_i_para1, configuration parameter for OBF (1)
#' @param obf_i_para2, configuration parameter for OBF (2)
#' @param PointedNode, set which nodes should be controlled.
#' @param PointValues, set corresponding values of controlled genes.
#' @param NodeDetailInfor, should return detail informations of node.
#' @param ReturnResidualNetwork, should return residual networks?
#' @details Please see document of \link{DNS_Engaged}
c_ScalingLaw_Simualtion <- function(sys_size, ll_system, obf_type, bias_rf, obf_ratio, net_type, net_f_para, obf_i_para1, obf_i_para2, PointedNode, PointValues, NodeDetailInfor, ReturnResidualNetwork) {
    .Call(`_BioLogical_c_ScalingLaw_Simualtion`, sys_size, ll_system, obf_type, bias_rf, obf_ratio, net_type, net_f_para, obf_i_para1, obf_i_para2, PointedNode, PointValues, NodeDetailInfor, ReturnResidualNetwork)
}

#' C++ prototype function for BoolBioNet_CoreDyn()
#' @param aRealNet, list-object of real/silico genetic network
#' @param PointedGene, integer or name vector, which nodes should be fixed.
#' @param PointValues, pointed values, for free or controlled nodes.
#' @param InD, in-degree vector.
#' @param OtD, out-degree vector.
#' @param NodeDetailInfor, should return detail informations of node.
#' @param ReturnResidualNetwork, should return Residual Network >0: yes.
#' @details Please see document of \link{BoolBioNet_CoreDyn}
c_ScalingLaw_RealNet <- function(aRealNet, PointedGene, PointValues, InD, OtD, NodeDetailInfor, ReturnResidualNetwork) {
    .Call(`_BioLogical_c_ScalingLaw_RealNet`, aRealNet, PointedGene, PointValues, InD, OtD, NodeDetailInfor, ReturnResidualNetwork)
}

#' C++ prototype function for BoolBioNet_CoreDyn()
#' @param aRealNet, list-object of real/silico genetic network
#' @param PointedGene, integer or name vector, which nodes should be fixed.
#' @param PointValues, pointed values, for free or controlled nodes.
#' @param InD, in-degree vector.
#' @param OtD, out-degree vector.
#' @param NodeDetailInfor, should return detail informations of node.
#' @param ReturnResidualNetwork, should return Residual Network >0: yes.
#' @param Times, recursive number of analysis.
#' @details Please see document of \link{BoolBioNet_CoreDyn}
c_CoreDynamicNode <- function(aRealNet, PointedGene, PointValues, InD, OtD, NodeDetailInfor, ReturnResidualNetwork, Times) {
    .Call(`_BioLogical_c_CoreDynamicNode`, aRealNet, PointedGene, PointValues, InD, OtD, NodeDetailInfor, ReturnResidualNetwork, Times)
}

#' C++ prototype function for BoolFun_Polynomial()
#' @param VariableMat, a matrix that record input variables.
#' @param MapTab, the truth table of Boolean function.
#' @param LogiSpin, an integer, set the detail form of Polynomial transformation.
#' @details Please see document of \link{BoolFun_Polynomial}
#' @return a List, [[1]] is.SAT ture or not? [[2]] Weights of coupled variable; [[3]] threshold.
c_BoolFun2Polynomial <- function(VariableMat, MapTab, LogiSpin) {
    .Call(`_BioLogical_c_BoolFun2Polynomial`, VariableMat, MapTab, LogiSpin)
}

#' C++ prototype function for BoolBioNet_StrConComp()
#' @param aRealNet, list-object of real/silico genetic network
#' @param InD, IntegerVector of in-degree
#' @param OtD, IntegerVector of out-degree
#' @details Please see document of \link{BoolBioNet_StrConComp}
#' @return a List, each element is a strong connect component.
c_StrongConnectComponent <- function(aRealNet, InD, OtD) {
    .Call(`_BioLogical_c_StrongConnectComponent`, aRealNet, InD, OtD)
}

#' C++ prototype function for MulVFun_Complexity()
#' @param avec, IntegerVector, each element in {0,1,...L-1}
#' @param k, input number (in-degree)
#' @param L, system of L:{v0,v1,...v_{L-1}}
#' @details Please see document of \link{MulVFun_Complexity}
#' @return numeric, the complexity of given function.
c_MulF_Complexity <- function(avec, k, L) {
    .Call(`_BioLogical_c_MulF_Complexity`, avec, k, L)
}

#' C++ prototype function for MulVFun_EffectiveEdges()
#' @param avec, IntegerVector, each element in {0,1,...L-1}
#' @param k, input number (in-degree)
#' @param L, system of L:{v0,v1,...v_{L-1}}
#' @details Please see document of \link{MulVFun_EffectiveEdges}
c_MulF_Effective <- function(avec, k, L) {
    .Call(`_BioLogical_c_MulF_Effective`, avec, k, L)
}

#' C++ prototype function for MulVFun_EffectiveEdges()
#' @param avec, IntegerVector, each element in {0,1,...L-1}
#' @param k, input number (in-degree)
#' @param L, system of L:{v0,v1,...v_{L-1}}
#' @details Please see document of \link{MulVFun_EffectiveEdges}
c_MulF_EffectiveEdges <- function(avec, k, L) {
    .Call(`_BioLogical_c_MulF_EffectiveEdges`, avec, k, L)
}

#' C++ prototype function for MulVFun_QMForm()
#' @param avec, IntegerVector, each element in {0,1,...L-1}
#' @param k, input number (in-degree)
#' @param L, system of L:{v0,v1,...v_{L-1}}
#' @details Please see document of \link{MulVFun_QMForm}
#' @return a matrix, rows are multi-valued prime implicants, columns are
#' each variable's state [0~L-1], -1 means "*". Last column is mapped results.
c_MulF_QuineMcCluskey <- function(avec, k, L) {
    .Call(`_BioLogical_c_MulF_QuineMcCluskey`, avec, k, L)
}

#' C++ prototype function for MulVFun_Generator()
#' @param FunType, function's type.
#' @param k, input variable size.
#' @param L, level of discrete system.
#' @param CanaDeep, layer of canalization.
#' @param CanaVar, Canalized varibale's ID.
#' @param CanaVarNum, Each canalizing number.
#' @param CanaInfo1, Rcpp::List, canalizing information.
#' @param CanaInfo2, Rcpp::List, canalized information.
#' @param bias, function's bias.
#' @param Cana_Free, is a parameter-free canalized function?
#' @details Please see document of \link{MulVFun_Generator}
c_MulVF_Generator <- function(FunType, k, L, CanaDeep, CanaVar, CanaVarNum, CanaInfo1, CanaInfo2, bias, Cana_Free) {
    .Call(`_BioLogical_c_MulVF_Generator`, FunType, k, L, CanaDeep, CanaVar, CanaVarNum, CanaInfo1, CanaInfo2, bias, Cana_Free)
}

#' C++ prototype function for MulVFun_Sensitivity()
#' @param amulfunss, a multi-valued function vector.
#' @param k, input variable size.
#' @param L, L-level discrete value.
#' @param Lens, length of mapping table: L^k.
#' @details Please see document of \link{MulVFun_Sensitivity}
c_MulVF_Sensitivity <- function(amulfunss, k, L, Lens) {
    .Call(`_BioLogical_c_MulVF_Sensitivity`, amulfunss, k, L, Lens)
}

#' C++ prototype function for MulVFun_is_NestedCanalized()
#' @param amulfunss, a multi-valued function vector.
#' @param k, input variable size.
#' @param L, L-level discrete value.
#' @param Lens, length of mapping table: L^k.
#' @details Please see document of \link{MulVFun_is_NestedCanalized}
c_M_NestedCanalized <- function(amulfunss, k, L, Lens) {
    .Call(`_BioLogical_c_M_NestedCanalized`, amulfunss, k, L, Lens)
}

#' C++ prototype function for MulVFun_is_Threshold()
#' @param amulfunss, a multi-valued function vector.
#' @param k, input variable size.
#' @param L, L-level discrete value.
#' @param Lens, length of mapping table: L^k.
#' @details Please see document of \link{MulVFun_is_Threshold}
c_M_Threshold <- function(amulfunss, k, L, Lens) {
    .Call(`_BioLogical_c_M_Threshold`, amulfunss, k, L, Lens)
}

#' C++ prototype function for MulVFun_is_Domainted()
#' @param amulfunss, a multi-valued function vector.
#' @param k, input variable size.
#' @param L, L-level discrete value.
#' @param Lens, length of mapping table: L^k.
#' @details Please see document of \link{MulVFun_is_Domainted}
c_M_Domainted <- function(amulfunss, k, L, Lens) {
    .Call(`_BioLogical_c_M_Domainted`, amulfunss, k, L, Lens)
}

#' C++ prototype function for MulVFun_is_Signed()
#' @param amulfunss, a multi-valued function vector.
#' @param k, input variable size.
#' @param L, L-level discrete value.
#' @param Lens, length of mapping table: L^k.
#' @details Please see document of \link{MulVFun_is_Signed}
c_M_Signed <- function(amulfunss, k, L, Lens) {
    .Call(`_BioLogical_c_M_Signed`, amulfunss, k, L, Lens)
}

#' C++ prototype function for MulVFun_Polynomial()
#' @param VariableMat, a matrix that record input variables.
#' @param MapTab, the truth table of multi-valued function.
#' @param k, input variable size.
#' @param L, L-level discrete value.
#' @details Please see document of \link{MulVFun_Polynomial}
#' @return a List, [[1]] is.SAT ture or not? [[2]] Weights of coupled variable; [[3]] thresholds of L-levels.
c_MulVFun2Polynomial <- function(VariableMat, MapTab, k, L) {
    .Call(`_BioLogical_c_MulVFun2Polynomial`, VariableMat, MapTab, k, L)
}

#' C++ prototype function for MulV2Bool_Bool2MulV()
#' @param OriMapTab, IntegerVector of original mapping table.
#' @param k, input variable size.
#' @param L, L-level discrete value.
#' @param Thresholds, IntegerVector of binary thresholds for multi-valued system.
#' @param b2m, Boolean value, Is from Boolean to Multi-valued system?
#' @details Please see document of \link{MulV2Bool_Bool2MulV}
c_MulV2Bool_Bool2MulV <- function(OriMapTab, k, L, Thresholds, b2m) {
    .Call(`_BioLogical_c_MulV2Bool_Bool2MulV`, OriMapTab, k, L, Thresholds, b2m)
}

